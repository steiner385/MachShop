# Database URL Secrets Template for MES Microservices
# IMPORTANT: Do NOT commit actual secrets to Git!
# These secrets store the complete DATABASE_URL connection strings
# Format: postgresql://username:password@host:port/database

# USAGE INSTRUCTIONS:
# 1. First, create the postgres username/password secrets using secrets-template.yaml
# 2. Then, create the DATABASE_URL secrets using the commands below
# 3. Each service needs its own DATABASE_URL secret

# The DATABASE_URL format for Prisma:
# postgresql://USERNAME:PASSWORD@HOST:PORT/DATABASE?schema=public

---
# Example: Manual secret creation for auth service
# kubectl create secret generic auth-db-secret \
#   --namespace=mes-production \
#   --from-literal=database-url='postgresql://mes_auth_user:YOUR_PASSWORD_HERE@postgres-auth:5432/mes_auth?schema=public'

---
# AUTOMATED SECRET GENERATION SCRIPT
# Copy and run this script to generate all database URL secrets
# Make sure to replace YOUR_PASSWORD_HERE with actual passwords

# #!/bin/bash
#
# # Generate secure passwords (store these securely!)
# AUTH_PASSWORD=$(openssl rand -base64 32)
# WORK_ORDER_PASSWORD=$(openssl rand -base64 32)
# QUALITY_PASSWORD=$(openssl rand -base64 32)
# MATERIAL_PASSWORD=$(openssl rand -base64 32)
# TRACEABILITY_PASSWORD=$(openssl rand -base64 32)
# RESOURCE_PASSWORD=$(openssl rand -base64 32)
# REPORTING_PASSWORD=$(openssl rand -base64 32)
# INTEGRATION_PASSWORD=$(openssl rand -base64 32)
#
# # Create database URL secrets for each service
# kubectl create secret generic auth-db-secret \
#   --namespace=mes-production \
#   --from-literal=database-url="postgresql://mes_auth_user:${AUTH_PASSWORD}@postgres-auth:5432/mes_auth?schema=public" \
#   --dry-run=client -o yaml | kubectl apply -f -
#
# kubectl create secret generic work-order-db-secret \
#   --namespace=mes-production \
#   --from-literal=database-url="postgresql://mes_work_order_user:${WORK_ORDER_PASSWORD}@postgres-work-order:5432/mes_work_order?schema=public" \
#   --dry-run=client -o yaml | kubectl apply -f -
#
# kubectl create secret generic quality-db-secret \
#   --namespace=mes-production \
#   --from-literal=database-url="postgresql://mes_quality_user:${QUALITY_PASSWORD}@postgres-quality:5432/mes_quality?schema=public" \
#   --dry-run=client -o yaml | kubectl apply -f -
#
# kubectl create secret generic material-db-secret \
#   --namespace=mes-production \
#   --from-literal=database-url="postgresql://mes_material_user:${MATERIAL_PASSWORD}@postgres-material:5432/mes_material?schema=public" \
#   --dry-run=client -o yaml | kubectl apply -f -
#
# kubectl create secret generic traceability-db-secret \
#   --namespace=mes-production \
#   --from-literal=database-url="postgresql://mes_traceability_user:${TRACEABILITY_PASSWORD}@postgres-traceability:5432/mes_traceability?schema=public" \
#   --dry-run=client -o yaml | kubectl apply -f -
#
# kubectl create secret generic resource-db-secret \
#   --namespace=mes-production \
#   --from-literal=database-url="postgresql://mes_resource_user:${RESOURCE_PASSWORD}@postgres-resource:5432/mes_resource?schema=public" \
#   --dry-run=client -o yaml | kubectl apply -f -
#
# kubectl create secret generic reporting-db-secret \
#   --namespace=mes-production \
#   --from-literal=database-url="postgresql://mes_reporting_user:${REPORTING_PASSWORD}@postgres-reporting:5432/mes_reporting?schema=public" \
#   --dry-run=client -o yaml | kubectl apply -f -
#
# kubectl create secret generic integration-db-secret \
#   --namespace=mes-production \
#   --from-literal=database-url="postgresql://mes_integration_user:${INTEGRATION_PASSWORD}@postgres-integration:5432/mes_integration?schema=public" \
#   --dry-run=client -o yaml | kubectl apply -f -

---
# ALTERNATIVE: If using existing postgres secrets, create DATABASE_URL from them
# This approach extracts the password from existing postgres secrets and creates DATABASE_URL

# #!/bin/bash
#
# NAMESPACE="mes-production"
# SERVICES=("auth" "work-order" "quality" "material" "traceability" "resource" "reporting" "integration")
#
# for SERVICE in "${SERVICES[@]}"; do
#   # Extract username and password from existing secret
#   USERNAME=$(kubectl get secret postgres-${SERVICE}-secret -n $NAMESPACE -o jsonpath='{.data.username}' | base64 -d)
#   PASSWORD=$(kubectl get secret postgres-${SERVICE}-secret -n $NAMESPACE -o jsonpath='{.data.password}' | base64 -d)
#
#   # Determine database name and host
#   DB_NAME="mes_${SERVICE//-/_}"
#   DB_HOST="postgres-${SERVICE}"
#
#   # Create DATABASE_URL
#   DATABASE_URL="postgresql://${USERNAME}:${PASSWORD}@${DB_HOST}:5432/${DB_NAME}?schema=public"
#
#   # Create secret
#   kubectl create secret generic ${SERVICE}-db-secret \
#     --namespace=$NAMESPACE \
#     --from-literal=database-url="$DATABASE_URL" \
#     --dry-run=client -o yaml | kubectl apply -f -
#
#   echo "Created ${SERVICE}-db-secret"
# done

---
# JWT Secret for all services
# kubectl create secret generic mes-secrets \
#   --namespace=mes-production \
#   --from-literal=jwt-secret=$(openssl rand -base64 64) \
#   --dry-run=client -o yaml | kubectl apply -f -

---
# VERIFICATION COMMANDS
# Verify that secrets were created successfully:
# kubectl get secrets -n mes-production | grep -E "db-secret|mes-secrets"

# View secret details (be careful - this will show the actual secret values):
# kubectl get secret auth-db-secret -n mes-production -o yaml

# Test DATABASE_URL format (without revealing password):
# kubectl get secret auth-db-secret -n mes-production -o jsonpath='{.data.database-url}' | base64 -d | sed 's/:.*@/:***@/'

---
# SECURITY BEST PRACTICES
# 1. Never commit actual passwords to Git
# 2. Use separate secrets for each service (Database Per Service pattern)
# 3. Store the generated passwords securely (use a password manager or secrets vault)
# 4. Rotate passwords regularly
# 5. Use RBAC to limit who can access secrets
# 6. Consider using external secrets management (HashiCorp Vault, AWS Secrets Manager, etc.)
# 7. Enable encryption at rest for etcd (where Kubernetes stores secrets)
# 8. Use network policies to restrict database access to authorized pods only

---
# DATABASE CONNECTION STRING COMPONENTS
# postgresql:// - Protocol
# username - Database user (created in StatefulSet)
# password - Secure random password (32+ characters)
# host - Service name (e.g., postgres-auth)
# port - PostgreSQL port (5432)
# database - Database name (e.g., mes_auth)
# ?schema=public - Prisma schema parameter

---
# TROUBLESHOOTING
# If pods can't connect to database:
# 1. Check that the secret exists:
#    kubectl get secret auth-db-secret -n mes-production
#
# 2. Verify DATABASE_URL format:
#    kubectl get secret auth-db-secret -n mes-production -o jsonpath='{.data.database-url}' | base64 -d
#
# 3. Test database connectivity from pod:
#    kubectl run -it --rm postgres-test --image=postgres:14-alpine --restart=Never -n mes-production -- \
#      psql postgresql://mes_auth_user:PASSWORD@postgres-auth:5432/mes_auth
#
# 4. Check PostgreSQL logs:
#    kubectl logs -n mes-production postgres-auth-0
#
# 5. Check service DNS resolution:
#    kubectl run -it --rm debug --image=busybox --restart=Never -n mes-production -- \
#      nslookup postgres-auth

---
# MIGRATION COMMANDS
# After creating secrets, run Prisma migrations in each service:
# kubectl exec -it auth-service-pod-name -n mes-production -- npx prisma migrate deploy
# kubectl exec -it work-order-service-pod-name -n mes-production -- npx prisma migrate deploy
# ... repeat for all services
