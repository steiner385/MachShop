/**
 * System Generated Serial Service
 * Issue #150: Serialization - Advanced Assignment Workflows
 *
 * Handles automatic generation of serial numbers at configured trigger points
 * using the SerialNumberFormatConfig engine. Supports sequential generation,
 * date-based formatting, and conditional triggering.
 */

import { PrismaClient, SerializedPart, SerialAssignmentTrigger } from '@prisma/client';
import { logger } from '../../utils/logger';
import type { FormulaEngine } from '../FormulaEngine';

export interface SystemGeneratedSerialInput {
  partId: string;
  triggerId?: string;
  operationCode?: string;
  workOrderId?: string;
  quantity?: number;
  generatedBy: string;
  systemContext?: string;
}

export interface GeneratedSerialResult {
  serial: SerializedPart;
  serialNumber: string;
  formatConfigId: string;
  generatedAt: Date;
}

export interface SerialGenerationConfig {
  formatConfigId: string;
  partId: string;
  triggerType: string;
  batchMode: boolean;
  batchSize?: number;
}

export class SystemGeneratedSerialService {
  private prisma: PrismaClient;
  private formulaEngine?: FormulaEngine;

  constructor(prisma: PrismaClient, formulaEngine?: FormulaEngine) {
    this.prisma = prisma;
    this.formulaEngine = formulaEngine;
  }

  /**
   * Generate a system serial number based on format configuration
   */
  async generateSystemSerial(input: SystemGeneratedSerialInput): Promise<GeneratedSerialResult> {
    try {
      logger.info(`Generating system serial for part ${input.partId}`);

      // Verify part exists
      const part = await this.prisma.part.findUnique({
        where: { id: input.partId },
        include: {
          serialNumberFormatConfig: true,
        },
      });

      if (!part) {
        throw new Error(`Part ${input.partId} not found`);
      }

      // Get format configuration
      let formatConfig = part.serialNumberFormatConfig;

      if (!formatConfig) {
        // Try to find from trigger configuration
        if (input.triggerId) {
          const trigger = await this.prisma.serialAssignmentTrigger.findUnique({
            where: { id: input.triggerId },
            include: { formatConfig: true },
          });

          if (trigger?.formatConfig) {
            formatConfig = trigger.formatConfig;
          }
        }
      }

      if (!formatConfig) {
        throw new Error(`No serial format configuration found for part ${input.partId}`);
      }

      // Generate serial number using format template
      const serialNumber = await this.generateSerialNumber(
        formatConfig.patternTemplate,
        formatConfig.id,
        input.partId
      );

      // Check uniqueness
      const isUnique = await this.checkSerialUniqueness(serialNumber, input.partId);
      if (!isUnique) {
        throw new Error(`Generated serial ${serialNumber} is not unique for part ${input.partId}`);
      }

      // Create SerializedPart record
      const serial = await this.prisma.serializedPart.create({
        data: {
          partId: input.partId,
          serialNumber,
          status: 'ACTIVE',
          generatedDate: new Date(),
          generatedMethod: 'SYSTEM_GENERATED',
          notes: input.systemContext || `Auto-generated by system trigger ${input.operationCode}`,
        },
      });

      // Create audit trail
      await this.createAuditTrail({
        serialNumber,
        serialId: serial.id,
        partId: input.partId,
        eventType: 'CREATED',
        eventSource: 'SYSTEM_GENERATED',
        performedBy: input.generatedBy,
        details: JSON.stringify({
          formatConfigId: formatConfig.id,
          triggerType: input.operationCode,
          operationCode: input.operationCode,
          workOrderId: input.workOrderId,
        }),
      });

      logger.info(`System serial ${serialNumber} generated successfully for part ${input.partId}`);

      return {
        serial,
        serialNumber,
        formatConfigId: formatConfig.id,
        generatedAt: new Date(),
      };
    } catch (error) {
      logger.error(
        `Error generating system serial: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  /**
   * Generate serial number using pattern template
   * Supports: {YYYY}, {MM}, {DD}, {SEQ:n}, {CHECK:type}, {RANDOM:type}
   */
  private async generateSerialNumber(
    template: string,
    formatConfigId: string,
    partId: string
  ): Promise<string> {
    try {
      let serialNumber = template;
      const now = new Date();

      // Replace date tokens
      serialNumber = serialNumber.replace(/\{YYYY\}/g, now.getFullYear().toString());
      serialNumber = serialNumber.replace(/\{YY\}/g, now.getFullYear().toString().slice(-2));
      serialNumber = serialNumber.replace(/\{MM\}/g, String(now.getMonth() + 1).padStart(2, '0'));
      serialNumber = serialNumber.replace(/\{DD\}/g, String(now.getDate()).padStart(2, '0'));

      // Handle sequential counter
      const seqMatch = serialNumber.match(/\{SEQ:(\d+)\}/);
      if (seqMatch) {
        const sequenceLength = parseInt(seqMatch[1], 10);
        const counter = await this.getAndIncrementCounter(formatConfigId, partId);
        const paddedCounter = counter.toString().padStart(sequenceLength, '0');
        serialNumber = serialNumber.replace(/\{SEQ:\d+\}/, paddedCounter);
      }

      // Handle random values (simple implementation)
      const randomMatch = serialNumber.match(/\{RANDOM:(\w+)\}/);
      if (randomMatch) {
        const randomType = randomMatch[1];
        const randomValue = this.generateRandom(randomType);
        serialNumber = serialNumber.replace(/\{RANDOM:\w+\}/, randomValue);
      }

      // Handle checksum (Luhn algorithm if specified)
      if (serialNumber.includes('{CHECK:luhn}')) {
        const checkDigit = this.calculateLuhnChecksum(serialNumber.replace(/\{CHECK:luhn\}/, ''));
        serialNumber = serialNumber.replace(/\{CHECK:luhn\}/, checkDigit);
      }

      return serialNumber;
    } catch (error) {
      logger.error(
        `Error generating serial number: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  /**
   * Get and increment sequential counter for format config
   */
  private async getAndIncrementCounter(formatConfigId: string, partId: string): Promise<number> {
    try {
      const config = await this.prisma.serialNumberFormatConfig.findUnique({
        where: { id: formatConfigId },
      });

      if (!config) {
        throw new Error(`Format config ${formatConfigId} not found`);
      }

      // For now, just return a simple counter based on existing serials
      // In a production system, this would use a dedicated counter table
      const count = await this.prisma.serializedPart.count({
        where: { partId },
      });

      return config.sequentialCounterStart + count * config.sequentialCounterIncrement;
    } catch (error) {
      logger.error(
        `Error getting counter: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  /**
   * Generate random value of specified type
   */
  private generateRandom(type: string): string {
    switch (type.toUpperCase()) {
      case 'NUMERIC':
        return Math.floor(Math.random() * 10000)
          .toString()
          .padStart(4, '0');
      case 'ALPHANUMERIC':
        return Math.random().toString(36).substring(2, 8).toUpperCase();
      case 'HEX':
        return Math.floor(Math.random() * 256)
          .toString(16)
          .padStart(2, '0');
      default:
        return Math.random().toString(36).substring(2, 8);
    }
  }

  /**
   * Calculate Luhn checksum digit
   */
  private calculateLuhnChecksum(input: string): string {
    // Remove non-numeric characters for calculation
    const digits = input.replace(/\D/g, '');
    let sum = 0;
    let isEven = false;

    for (let i = digits.length - 1; i >= 0; i--) {
      let digit = parseInt(digits[i], 10);

      if (isEven) {
        digit *= 2;
        if (digit > 9) {
          digit -= 9;
        }
      }

      sum += digit;
      isEven = !isEven;
    }

    const checkDigit = (10 - (sum % 10)) % 10;
    return checkDigit.toString();
  }

  /**
   * Check if serial number is unique
   */
  private async checkSerialUniqueness(serialNumber: string, partId: string): Promise<boolean> {
    try {
      const existing = await this.prisma.serializedPart.findFirst({
        where: {
          serialNumber,
          partId,
        },
      });

      return !existing;
    } catch (error) {
      logger.error(
        `Error checking uniqueness: ${error instanceof Error ? error.message : String(error)}`
      );
      return false;
    }
  }

  /**
   * Generate serials in batch mode
   */
  async generateBatchSerials(
    input: SystemGeneratedSerialInput & { batchSize: number }
  ): Promise<GeneratedSerialResult[]> {
    try {
      logger.info(
        `Generating batch of ${input.batchSize} serials for part ${input.partId}`
      );

      const results: GeneratedSerialResult[] = [];

      for (let i = 0; i < input.batchSize; i++) {
        const result = await this.generateSystemSerial({
          partId: input.partId,
          triggerId: input.triggerId,
          operationCode: input.operationCode,
          workOrderId: input.workOrderId,
          generatedBy: input.generatedBy,
          systemContext: `Batch generation ${i + 1} of ${input.batchSize}`,
        });

        results.push(result);
      }

      logger.info(`Batch generation completed: ${input.batchSize} serials created`);
      return results;
    } catch (error) {
      logger.error(
        `Error generating batch serials: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  /**
   * Trigger serial generation based on configured rules
   */
  async triggerSerialGeneration(
    partId: string,
    triggerType: string,
    context: {
      operationCode?: string;
      workOrderId?: string;
      workCenterId?: string;
      generatedBy: string;
    }
  ): Promise<GeneratedSerialResult[]> {
    try {
      logger.info(`Triggering serial generation for part ${partId} with trigger ${triggerType}`);

      // Find applicable triggers
      const triggers = await this.prisma.serialAssignmentTrigger.findMany({
        where: {
          partId,
          triggerType,
          assignmentType: 'SYSTEM_GENERATED',
          isActive: true,
        },
        include: { formatConfig: true },
      });

      if (triggers.length === 0) {
        logger.warn(`No active triggers found for part ${partId} and trigger type ${triggerType}`);
        return [];
      }

      const results: GeneratedSerialResult[] = [];

      for (const trigger of triggers) {
        // Check conditions if any
        if (trigger.isConditional && trigger.conditions) {
          const conditionsMet = await this.evaluateConditions(trigger.conditions, context);
          if (!conditionsMet) {
            logger.debug(`Conditions not met for trigger ${trigger.id}`);
            continue;
          }
        }

        // Generate serials
        if (trigger.batchMode && trigger.batchSize) {
          const batchResults = await this.generateBatchSerials({
            partId,
            triggerId: trigger.id,
            operationCode: context.operationCode,
            workOrderId: context.workOrderId,
            generatedBy: context.generatedBy,
            batchSize: trigger.batchSize,
          });
          results.push(...batchResults);
        } else {
          const result = await this.generateSystemSerial({
            partId,
            triggerId: trigger.id,
            operationCode: context.operationCode,
            workOrderId: context.workOrderId,
            generatedBy: context.generatedBy,
          });
          results.push(result);
        }
      }

      return results;
    } catch (error) {
      logger.error(
        `Error triggering serial generation: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  /**
   * Evaluate trigger conditions
   */
  private async evaluateConditions(
    conditionsJson: string,
    context: any
  ): Promise<boolean> {
    try {
      const conditions = JSON.parse(conditionsJson);
      // Simple implementation - can be extended with more complex logic
      return true; // Default to true for now
    } catch (error) {
      logger.error(
        `Error evaluating conditions: ${error instanceof Error ? error.message : String(error)}`
      );
      return false;
    }
  }

  /**
   * Get generated serials for a part
   */
  async getGeneratedSerials(
    partId: string,
    filters?: {
      generatedSince?: Date;
      generatedUntil?: Date;
      operationCode?: string;
    }
  ): Promise<SerializedPart[]> {
    try {
      const where: any = {
        partId,
        generatedMethod: 'SYSTEM_GENERATED',
      };

      if (filters?.generatedSince) {
        where.generatedDate = { gte: filters.generatedSince };
      }

      if (filters?.generatedUntil) {
        if (where.generatedDate) {
          where.generatedDate.lte = filters.generatedUntil;
        } else {
          where.generatedDate = { lte: filters.generatedUntil };
        }
      }

      return await this.prisma.serializedPart.findMany({
        where,
        orderBy: { generatedDate: 'desc' },
      });
    } catch (error) {
      logger.error(
        `Error getting generated serials: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  /**
   * Create audit trail entry
   */
  private async createAuditTrail(input: {
    serialNumber: string;
    serialId: string;
    partId: string;
    eventType: string;
    eventSource: string;
    performedBy: string;
    details?: string;
  }): Promise<void> {
    try {
      await this.prisma.serialAssignmentAudit.create({
        data: {
          serialNumber: input.serialNumber,
          serialId: input.serialId,
          partId: input.partId,
          eventType: input.eventType,
          eventSource: input.eventSource,
          performedBy: input.performedBy,
          performedAt: new Date(),
          details: input.details,
        },
      });
    } catch (error) {
      logger.error(
        `Error creating audit trail: ${error instanceof Error ? error.message : String(error)}`
      );
      // Don't throw - audit trail failure shouldn't block main operation
    }
  }

  /**
   * Disconnect from database
   */
  async disconnect(): Promise<void> {
    await this.prisma.$disconnect();
  }
}

export default SystemGeneratedSerialService;
