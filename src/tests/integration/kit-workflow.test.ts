/**
 * Kit Workflow Integration Test
 *
 * Tests the end-to-end kit workflow from generation to consumption
 * Verifies integration between all services and proper data flow
 */

import { describe, beforeEach, afterEach, it, expect, vi } from 'vitest';
import { PrismaClient } from '@prisma/client';
import { KitGenerationService } from '../../services/KitGenerationService';
import { StagingLocationService } from '../../services/StagingLocationService';
import { KitWorkflowService } from '../../services/KitWorkflowService';
import { KitShortageService } from '../../services/KitShortageService';

// Mock Prisma for testing
const mockPrisma = {
  kit: {
    findUnique: vi.fn(),
    findMany: vi.fn(),
    create: vi.fn(),
    update: vi.fn(),
    count: vi.fn()
  },
  kitItem: {
    findMany: vi.fn(),
    create: vi.fn(),
    update: vi.fn()
  },
  workOrder: {
    findUnique: vi.fn()
  },
  bOMItem: {
    findMany: vi.fn(),
    count: vi.fn()
  },
  part: {
    findUnique: vi.fn(),
    findMany: vi.fn()
  },
  stagingLocation: {
    findMany: vi.fn(),
    findUnique: vi.fn(),
    update: vi.fn(),
    fields: {
      maxCapacity: 'maxCapacity' // Mock field reference
    }
  },
  kitStatusHistory: {
    create: vi.fn()
  },
  kitShortageAlert: {
    findFirst: vi.fn(),
    create: vi.fn(),
    update: vi.fn(),
    findMany: vi.fn()
  },
  $transaction: vi.fn()
} as unknown as PrismaClient;

describe('Kit Workflow Integration', () => {
  let kitGenerationService: KitGenerationService;
  let stagingLocationService: StagingLocationService;
  let kitWorkflowService: KitWorkflowService;
  let kitShortageService: KitShortageService;

  beforeEach(() => {
    vi.clearAllMocks();

    // Initialize services with mocked Prisma
    kitGenerationService = new KitGenerationService(mockPrisma);
    stagingLocationService = new StagingLocationService(mockPrisma);
    kitWorkflowService = new KitWorkflowService(mockPrisma);
    kitShortageService = new KitShortageService(mockPrisma);

    // Setup common mocks
    mockPrisma.$transaction.mockImplementation(async (callback) => {
      return await callback(mockPrisma);
    });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should complete end-to-end kit workflow', async () => {
    // Test data setup
    const workOrderId = 'test-work-order-1';
    const kitId = 'test-kit-1';
    const locationId = 'test-location-1';
    const userId = 'test-user-1';

    // Mock work order with BOM
    const mockWorkOrder = {
      id: workOrderId,
      workOrderNumber: 'WO-12345',
      partId: 'part-1',
      quantity: 1,
      part: {
        id: 'part-1',
        partNumber: 'ENG-001',
        partName: 'Engine Assembly',
        bomItems: [
          {
            id: 'bom-1',
            componentPartId: 'comp-1',
            quantity: 2,
            componentPart: {
              id: 'comp-1',
              partNumber: 'COMP-001',
              partName: 'Component 1',
              inventoryItems: [
                { quantity: 10, isActive: true }
              ]
            }
          }
        ]
      }
    };

    const mockKit = {
      id: kitId,
      kitNumber: 'KIT-WO-12345-01-20241030',
      kitName: 'Complete Kit - ENG-001',
      workOrderId: workOrderId,
      status: 'PLANNED',
      priority: 'NORMAL',
      autoGenerated: true,
      generatedFromBOM: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      kitItems: [
        {
          id: 'kit-item-1',
          kitId: kitId,
          partId: 'comp-1',
          requiredQuantity: 2,
          status: 'PLANNED'
        }
      ]
    };

    const mockStagingLocation = {
      id: locationId,
      locationCode: 'STG-A1',
      locationName: 'Assembly Area 1 Staging',
      isActive: true,
      isAvailable: true,
      currentOccupancy: 2,
      maxCapacity: 10,
      locationType: 'ASSEMBLY',
      isCleanRoom: false,
      securityLevel: 'STANDARD',
      maintenanceMode: false,
      proximityScore: 85,
      nearWorkCells: ['work-cell-1', 'work-cell-2'],
      area: {
        id: 'area-1',
        areaName: 'Assembly Area 1',
        isActive: true
      },
      kits: []
    };

    // Setup mocks
    mockPrisma.workOrder.findUnique.mockResolvedValue(mockWorkOrder);
    mockPrisma.bOMItem.findMany.mockResolvedValue(mockWorkOrder.part.bomItems);
    mockPrisma.bOMItem.count.mockResolvedValue(0); // No sub-BOMs
    mockPrisma.kit.create.mockResolvedValue(mockKit);
    mockPrisma.kitItem.create.mockResolvedValue(mockKit.kitItems[0]);

    // Create stateful kit mock
    let currentKit = { ...mockKit };

    // Mock kit findUnique for multiple calls
    mockPrisma.kit.findUnique.mockImplementation((args) => {
      if (args.where.id === kitId) {
        return Promise.resolve({
          ...currentKit,
          kitItems: mockKit.kitItems.map(item => ({
            ...item,
            part: {
              id: 'comp-1',
              partNumber: 'COMP-001',
              partName: 'Component 1'
            }
          })),
          workOrder: mockWorkOrder,
          operation: null,
          stagingLocation: mockStagingLocation
        });
      }
      return Promise.resolve(null);
    });

    // Mock staging location queries
    mockPrisma.stagingLocation.findMany.mockImplementation((args) => {
      // Handle the complex where conditions from getAvailableLocations
      return Promise.resolve([mockStagingLocation]);
    });
    mockPrisma.stagingLocation.findUnique.mockImplementation((args) => {
      if (args.where.id === locationId) {
        return Promise.resolve(mockStagingLocation);
      }
      return Promise.resolve(null);
    });
    mockPrisma.stagingLocation.update.mockResolvedValue(mockStagingLocation);

    // Mock kit.update to handle status changes
    mockPrisma.kit.update.mockImplementation((args) => {
      if (args.data.status) {
        currentKit.status = args.data.status;
      }
      if (args.data.stagingLocationId) {
        currentKit.stagingLocationId = args.data.stagingLocationId;
      }
      return Promise.resolve({ ...currentKit });
    });

    mockPrisma.kitStatusHistory.create.mockResolvedValue({});

    try {
      // Step 1: Generate kit from work order
      console.log('Testing kit generation...');
      const generationResult = await kitGenerationService.generateKitsForWorkOrder({
        workOrderId: workOrderId,
        assemblyStage: 'COMPLETE',
        priority: 'NORMAL'
      });

      expect(generationResult.kits).toHaveLength(1);
      expect(generationResult.kits[0].kitNumber).toContain('KIT-WO-12345');
      expect(generationResult.analysis.totalItems).toBeGreaterThan(0);

      // Step 2: Find optimal staging location
      console.log('Testing staging location optimization...');
      const locationResult = await stagingLocationService.findOptimalLocation({
        kitId: kitId,
        workCellId: 'work-cell-1'
      });

      expect(locationResult.recommendedLocation).toBeDefined();
      expect(locationResult.score.score).toBeGreaterThan(0);

      // Step 3: Assign kit to staging location
      console.log('Testing kit staging assignment...');
      await stagingLocationService.assignKitToLocation(kitId, locationId, userId);

      // Verify staging assignment was called
      expect(mockPrisma.kit.update).toHaveBeenCalledWith({
        where: { id: kitId },
        data: expect.objectContaining({
          stagingLocationId: locationId,
          status: 'STAGED'
        })
      });

      // Step 4: Transition kit status
      console.log('Testing kit status transition...');
      const transitionResult = await kitWorkflowService.transitionKitStatus({
        kitId: kitId,
        newStatus: 'ISSUED',
        userId: userId,
        reason: 'Kit ready for production'
      });

      console.log('Transition result:', JSON.stringify(transitionResult, null, 2));

      expect(transitionResult.success).toBe(true);
      expect(transitionResult.newStatus).toBe('ISSUED');

      // Step 5: Test shortage identification (simplified)
      console.log('Testing shortage identification...');

      // Test that shortage service is properly instantiated
      expect(kitShortageService).toBeDefined();
      expect(typeof kitShortageService.identifyShortages).toBe('function');

      console.log('✅ End-to-end kit workflow test completed successfully');

    } catch (error) {
      console.error('❌ End-to-end test failed:', error);
      throw error;
    }
  });

  it('should handle kit generation validation', async () => {
    // Test invalid work order
    mockPrisma.workOrder.findUnique.mockResolvedValue(null);

    await expect(
      kitGenerationService.generateKitsForWorkOrder({
        workOrderId: 'invalid-id'
      })
    ).rejects.toThrow('Work order invalid-id not found');
  });

  it('should validate status transitions', async () => {
    const mockKit = {
      id: 'kit-1',
      status: 'CONSUMED', // Terminal state
      kitItems: []
    };

    mockPrisma.kit.findUnique.mockResolvedValue(mockKit);

    const result = await kitWorkflowService.transitionKitStatus({
      kitId: 'kit-1',
      newStatus: 'ISSUED', // Invalid transition from CONSUMED
      userId: 'user-1'
    });

    expect(result.success).toBe(false);
    expect(result.validationResults).toContainEqual(
      expect.objectContaining({
        type: 'ERROR',
        message: expect.stringContaining('Invalid transition')
      })
    );
  });

  it('should handle staging location constraints', async () => {
    // Mock a kit for the test
    const mockKit = {
      id: 'kit-1',
      kitItems: [],
      workOrder: { id: 'wo-1' }
    };

    // Test with no available locations
    mockPrisma.kit.findUnique.mockResolvedValue(mockKit);
    mockPrisma.stagingLocation.findMany.mockResolvedValue([]);

    await expect(
      stagingLocationService.findOptimalLocation({
        kitId: 'kit-1',
        requiresCleanRoom: true
      })
    ).rejects.toThrow('No suitable staging locations available');
  });

  it('should calculate kit metrics correctly', async () => {
    const mockKits = [
      {
        id: 'kit-1',
        status: 'CONSUMED',
        createdAt: new Date('2024-01-01'),
        stagedAt: new Date('2024-01-02'),
        issuedAt: new Date('2024-01-03'),
        kitItems: [
          { requiredQuantity: 10, consumedQuantity: 10 }
        ],
        statusHistory: []
      },
      {
        id: 'kit-2',
        status: 'STAGED',
        createdAt: new Date('2024-01-01'),
        stagedAt: new Date('2024-01-02'),
        kitItems: [
          { requiredQuantity: 5, consumedQuantity: 0 }
        ],
        statusHistory: []
      }
    ];

    mockPrisma.kit.findMany.mockResolvedValue(mockKits);

    const metrics = await kitWorkflowService.getKitMetrics();

    expect(metrics.totalKits).toBe(2);
    expect(metrics.statusDistribution.CONSUMED).toBe(1);
    expect(metrics.statusDistribution.STAGED).toBe(1);
    expect(metrics.completionRate).toBe(50); // 1 of 2 completed
  });
});

// Export for use in other tests
export {
  mockPrisma,
  KitGenerationService,
  StagingLocationService,
  KitWorkflowService,
  KitShortageService
};